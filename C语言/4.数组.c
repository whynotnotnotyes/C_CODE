#define _CRT_SECURE_NO_WARNINGS 1



//数组

//数组是一组相同类型元素的集合。
//数组的创建方式: type_t  arr_name  [const_n]
			   //type_t 是指数组的元素类型
			   // arr_name是指数组的元素名
			   //const_n是一个常量表达式，用来指定数组的大小


//#include <stdio.h>
//
//int main()
//{
//	int arr[10] = { 1,2,3 };
//	//整型数组不完全初始化，剩下的元素默认初始化为0
//
//	char arr2[5] = { 'a','b','c' };
//	//以上是字符数组，剩下元素默认初始化为\0
//
//	char arr3[5] = { 'a',98 };
//	//98会变成b,因为这是字符数组，98在ASCII码表里面对应的字符是b,就会解析成b
//
//	char arr4[7] = "abc";
//	//以上是字符串数组，abc后面还有一个\0
//
//	char arr5[] = "abcdefg";
//	//不指定大小，g后面还会有一个'\0'
//
//	char arr6[3] = { 1,2,3};
//	
//	printf("%d\t%d\t%d\t%d\t%d\t%d\n\n\n", strlen(arr),strlen(arr2),strlen(arr3),strlen(arr4),strlen(arr5),strlen(arr6));
//
//
//	//arr6是字符数组，而strlen以字符串结束，而字符数组后面没有\0，所以是个随机值
//
//	printf("%d\t%d\t%d\t%d\t%d\t%d\n", sizeof(arr), sizeof(arr2), sizeof(arr3), sizeof(arr4), sizeof(arr5), sizeof(arr6));
//
//	return 0;
//}

//总之不管怎么样，字符串数组后面都会有一个'\0'，因为这是判断数组结束的标志
//整型数组后面没有\0，未完全初始化整型数组后面默认为0
//字符数组和整型数组后面都没有\0





//sizeof和strlen没有什么关系

//#include <stdio.h>
//#include <string.h>
//int main()
//{
//	char arr[] = "abcdef";
//
//	char arr1[] = { 'a','b','c', 'd','e','f'};
//
//	printf("%d\n", strlen(arr1));
//
//	printf("%d\n", sizeof(arr));
//	//sizeof是计算arr所占空间的大小，单位是字节,\0也会占空间，所以\0也算进空间
//	printf("%d\n", strlen(arr));
//	//strlen是计算字符串数组的长度，到\0就停止，所以\0不算进长度
//
//	return 0;
//}


//sizeof和strlen没有什么关联
//strlen是求字符串长度的-只能针对字符串求长度 - 库函数 - 得引头文件
//sizeof是计算变量，数组，类型的大小-单位是字节-操作符(像加减乘除就是操作符，不是函数，不用引头文件)



//#include <stdio.h>
//#include <string.h>
//
//int main()
//{
//	char arr[] = "abc";
//	//未初始化和完全初始化都是4个元素，但是未初始化监视窗口会显示\0
//	char arr1[3] = "abc";
//
//	printf("%d\n", sizeof(arr));
//	printf("%d\n", sizeof(arr1));
//
//	printf("%d\n", strlen(arr));
//	printf("%d\n", strlen(arr1));
// 
//}






//题目：以下sizeof和strlen各是多少？
//#include <stdio.h>
//#include <string.h>
//
//int main()
//{
//	char arr1[] = "abc";
//	char arr2[] = { 'a','b','c' };
//
//	printf("%d\n", sizeof(arr1));
//	//arr1是字符串数组，字符串以\0结尾，所以字符串后面都会有\0，所以占据4个空间，每个空间是1(char)
//	printf("%d\n", sizeof(arr2));
//	//arr2是字符数组，字符不是以\0结尾，多少个就是多少个
//
//	printf("%d\n", strlen(arr1));
//	//arr1是字符串数组,计算字符串到\0结束，所以是3
//	printf("%d\n", strlen(arr2));
//	//arr2是字符数组，而strlen以字符串结束，而字符数组后面没有\0，所以是个随机值
//
//	return 0;
//}




//#include <stdio.h>
//#include <string.h>
//
//int main()
//{
//	char arr[] = "abcdef";
//
//	int i = 0;
//
//	int len = strlen(arr);
//
//	for (i = 0; i < len; i++)
//	{   //strlen返回的是一个无符号整型(unsigned int)，所以要强制转换成int:i<(int)strlen(arr);但一般不这么写
//		printf("%c ", arr[i]);
//	}
//
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	//sizeof可以求字符串数组也可以求整型数组
//	printf("%d\n", sz);
//	//结果是7,因为有一个\0
//
//	return 0;
//}





//一维数组在内存中的存储

//#include <stdio.h>
//
//int main()
//{
//	int arr[] = { 1,2,3,4,5,6 };
//
//	int i = 0;
//	int sz = sizeof(arr) / sizeof(arr[0]);
//
//	for (i = 0; i < sz; i++)
//	{
//		printf("&arr[%d ] = %p\n", i, &arr[i]);
//	}
//
//	return 0;
//}

//以下是输出的结果,得出的结论：
//数组是连续存放的,根据类型分配相同大小的空间
//下标为0就是低地址，往上就是高地址

//& arr[0] = 00000051003CFBD8
//& arr[1] = 00000051003CFBDC
//& arr[2] = 00000051003CFBE0
//& arr[3] = 00000051003CFBE4
//& arr[4] = 00000051003CFBE8
//& arr[5] = 00000051003CFBEC





//二维数组的创建

//#include <stdio.h>
//
//int main()
//{
//	int arr[3][4] = { {1,2,3},{4,5},{6,7,5}};
//
//	return 0;
//}

////二维数组未完全初始化，默认值也是0
//二维数组行的下标可以省略，不能省略列






//遍历二维数组
//二维数组依然是通过下标来访问

//#include <stdio.h>
//
//int main()
//{
//	int arr[3][4] = { {1,2,3},{4,5,6} };
//
//	int i = 0;
//
//	for (i = 0; i < 3; i++)
//	{
//		int j = 0;
//		
//		for (j = 0; j < 4; j++)
//		{
//			printf("%d ", arr[i][j]);
//		}
//		printf("\n");
//	}
//	return 0;
//}






//二维数组在内存中的存储

//#include <stdio.h>
//
//int main()
//{
//	int arr[3][4] = { {1,2,3},{4,5} };
//
//	int i = 0;
//
//	for (i = 0; i < 3; i++)
//	{
//		int j = 0;
//		for (j = 0; j < 4; j++)
//		{
//			printf("&arr[%d][%d] = %p\n", i, j, &arr[i][j]);
//		}
//	}
//
//	return 0;
//
//}

//三行的二维数组是由三行一维数组组成的
//多维数组是一维数组的数组

//以上代码的输出结果

//& arr[0][0] = 0000002DDFD2F818
//& arr[0][1] = 0000002DDFD2F81C
//& arr[0][2] = 0000002DDFD2F820
//& arr[0][3] = 0000002DDFD2F824
//& arr[1][0] = 0000002DDFD2F828
//& arr[1][1] = 0000002DDFD2F82C
//& arr[1][2] = 0000002DDFD2F830
//& arr[1][3] = 0000002DDFD2F834
//& arr[2][0] = 0000002DDFD2F838
//& arr[2][1] = 0000002DDFD2F83C
//& arr[2][2] = 0000002DDFD2F840
//& arr[2][3] = 0000002DDFD2F844

//结论：二维数组和一维数组在内存存储中一样，也是连续存储的














//冒泡排序

//#include <stdio.h>
//
//void bubble_sort(int arr[], int sz) //int arr[]就是指针变量，写成int* arr一样可以
//                                    //int* 是对某个整形取地址，int arr[]是系统默认取数组首元素地址
//{
//	int i = 0;
//
//	for (i = 0; i < sz - 1; i++)
//	{
//		int j = 0;
//		int flag = 1;  //提升效率
//
//		for (j = 0; j < sz - 1 - i; j++)
//		{
//			
//			if (arr[j] > arr[j + 1])
//			{
//				int tmp = arr[j];
//				arr[j] = arr[j + 1];
//				arr[j + 1] = tmp;
//				flag = 0;
//			}
//		}
//
//		if (flag == 1)
//		{
//			break;
//		}
//	}
//}
//
//int main()
//{
//	int arr[10] = { 9,8,6,7,3,4,5,0,2,1 };
//
//	int sz = sizeof(arr) / sizeof(arr[0]);
//
//	bubble_sort(arr,sz);//形参是实参的一份临时拷贝，传数组的时候电脑不会这么傻把全部传过去，因为如果一个数组有一万个元素
//                      //相当于把存储空间涨了一倍，所以为了避免空间浪费，只是传过去数组首元素的第一个地址
//                      //因为数组是连续存储的，数组第一个元素+1就是第二个元素
//
//	int  i = 0;
//
//	for (i = 0; i < sz; i++)
//	{
//		printf("%d ", arr[i]);
//	}
//
//	printf("\n");
//
//	return 0;
//}

//10个元素就是9趟，9个元素就是8趟

//第一趟排序
//9对对比

//第二趟排序，不用排最后一位，因为已经和所有数对比过，是最大了，所以跳出循环的条件是sz - 1 - i，i此时是0
//10 - 1 - 0 = 9   ， i每一趟加1，每一趟减去已经排序好了的数

//...以此类推






//数组名

//#include <stdio.h>
//
//int main()
//{
//	int arr[5] = { 1,2,3,4,5 };
//
//	printf("%p\n", arr);
//	printf("%p\n\n", arr + 1);
// 
//	printf("%p\n", &arr[0]); //数组名就是首元素的地址
//	printf("%p\n\n", &arr[0] + 1);
//
//	printf("%d\n\n", *arr); //数组名解引用操作就是数组的第一个元素
// 
//	printf("%p\n",&arr);//这里&arr取了所有元素的地址，是连续的，后面给省略了
//	printf("%d\n", sizeof(&arr + 5)); 
//	printf("%p\n\n", &arr + 1);
//	
//
//	printf("%d\n", sizeof(*arr));
//	printf("%d\n\n", sizeof(arr));
// 
//	return 0;
//}

//数组名就是首元素的地址,但是有两种例外：
// 1.sizeof（数组名）中的数组名是整个数组的元素的内存空间，单位是字节
// 2.&arr,取地址时取出来的是整个数组的地址
//除了以上两种情况，其余所有情况(arr)数组名都是第一个元素的地址

//数组名解引用操作就是数组的第一个元素









//三子棋

//#include <stdio.h>
//#include "add.h"
//#include <stdlib.h>
//#include <time.h>
//
//void menu()
//{
//	printf("******************************\n");
//	printf("******* 1.play  2.exit *******\n");
//	printf("******************************\n");
//}
////游戏的整个算法实现
//void game()
//{	//数组-存放走出的棋盘信息
//	char board[ROW][COL] = { 0 };
//
//	int ret = 0;
//
//	//初始化棋盘,初始化后数组里放的都是空格
//	InitBoard(board, ROW, COL);
//
//	//打印棋盘
//	DisplayBoard(board,ROW,COL);
//
//	while (1)
//	{
//		//玩家走棋
//		PlayerMove(board, ROW, COL);
//		DisplayBoard(board,ROW,COL);
//		system("cls");
//
//		//判断玩家是否赢	         返回四个结果：1.玩家赢 2.电脑赢 3.都没赢继续下 4.平局
//		ret = IsWin(board,ROW,COL);
//
//
//		//电脑走棋
//		ComputerMove(board, ROW, COL);
//		DisplayBoard(board, ROW, COL);
//
//		//判断电脑是否赢
//		ret = IsWin(board,ROW,COL);
//
//		if (ret != 'C')
//		{
//			break;
//		}
//	}
//	if (ret == '*')
//	{
//		printf("你赢了!\n\n");
//	}
//	else if (ret == '#')
//	{
//		printf("电脑赢了\n\n");
//	}
//	else if (ret == 'Q')
//	{
//		printf("平局\n");
//	}
//}
//
//void test()
//{
//	srand((unsigned int)time(NULL));
//
//	int input = 0;
//
//	do {
//		menu();
//		printf("请输入:>\n");
//
//		scanf("%d", &input);
//
//		switch (input)
//		{
//			case 1:
//				game();
//				break;
//			case 0:
//				printf("退出游戏\n");
//				break;
//			default:
//				printf("选择错误，重新选择\n");
//				break;
//		}
//	} while (input);
//}
//
//int main()
//{
//	test();
//
//	return 0;
//}










//扫雷

//#include <stdio.h>
//#include "add.h"
//#include <stdlib.h>
//#include <time.h>
//
//
//void menu()
//{
//	printf("**********************************\n");
//	printf("************  1.play  ************\n");
//	printf("************  2.exit  ************\n");
//	printf("**********************************\n\n");
//}
//
//void game()
//{
//	//雷的信息存储
//	//1.布置好的雷的信息
//	char mine[ROWS][COLS] = { 0 };  //11*11  
//	//2.排查出的雷的信息
//	char show[ROWS][COLS] = { 0 };
//	//为什么排查出的雷的信息也要设置成11*11，因为不设置相同的化就会坐标不同步
//
//	//初始化棋盘
//	InitBoard(mine, ROWS, COLS, '0');
//	InitBoard(show, ROWS, COLS, '*');
//
//	//共两个数组，所以初始化两个数组
//
//	//打印棋盘
//  //DisplayBoard(mine, ROW, COL);
//	DisplayBoard(show, ROW, COL);
//
//	//布置雷
//	SetMine(mine, ROW, COL);
//	//DisplayBoard(mine, ROW, COL);
//
//	//扫雷
//	FindMine(mine, show, ROW, COL);
//}
//
//void test()
//{
//	int input = 0;
//
//	srand((unsigned int)time(NULL));
//
//	do {
//
//		menu();
//
//		printf("请选择:>(1/0)\n");
//		
//		scanf("%d", &input);
//
//		switch (input)
//		{
//			case 1:
//				game();
//				break;
//			case 0:
//				printf("退出游戏");
//				break;
//			default:
//				printf("选择错误，请重新输入");
//				break;
//		}
//	} while (input);
//}
//
//int main()
//{
//	test();
//
//	return 0;
//}














//操作符详解


//	分类：



//算术操作符 + = * / 加减乘除

//#include <stdio.h>
//
//int main()
//{
//	int a = 5 / 2;	//除得到商数
//	int b = 5 % 2;	//模得到余数,对于取模，左操作数和右操作数都必须是 整型 ,不然会报错
//
//	double c = 5 / 2.0;  //要想得到正确的浮点数结果，除数和被除数需要有一边是浮点数,用整型会丢失精度
//
//	printf("5/2 = %d\n", a);
//	printf("5%%2 = %d\n\n", b);
//
//	printf("5/2.0 = %lf\n", c);
//}








//移位操作符：通常是算术移位，而不是逻辑移位

//算术右移 >>：右移补码右边丢弃，左边补原符号位（正数补0，负数补1）
//逻辑右移：右移补码右边丢弃，左边补0

//移位是对补码进行移位

//移位操作符和位操作符只能应用于整数，不能用浮点数
//移位操作符,位操作符,按位取反,运算,隐式类型转换，都是用补码进行计算，只不过正数的补码原码反码相同

//#include <stdio.h>
//
//int main()
//{
//	int a = 16;
//	int b = a >> 1;
//	//算数右移一位相当于原数除以2，算数左移移位相当于原数乘以2
//
//	printf("a>>1 = %d\n\n", b);
//	//移位操作符是算术移位，a得补码向右移动一位，右边丢弃一位，最左边补上一个原来的符号位;
//	//                     如果是向左移动一位，左边丢弃一位，最右边补0
//
//
//
//	//整数的二进制表示有三种：原码，反码，补码
//	//存储到内存的是补码
//	//正数的原码，反码，补码相同
//	//负数在内存中存得是补码，显示是原码
//
//	//如何证明负数在内存中存的是补码？
//	//按f10，点击调试，找到内存，点开，搜索框取地址c:&c,会看到8个f,f是16进制，转换成二进制是4个1，8个f就是32
//
//	int c = -16;
//
//	int d = c >> 1;
//	//原码：10000000 000000000 00000000 00010000
//	//反码：11111111  11111111 11111111 11101111
//	//补码：11111111  11111111 11111111 11110000
//
//	//补码右移一位：   11111111 11111111 11111111 1111000
//	//左边补原符号位：11111111 11111111 11111111 11111000
//
//	//补码减一得反码:11111111 11111111 11111111 11110111
//	//反码取反得原码：10000000 00000000 00000000 00001000
//
//	//转成二进制得-8
//
//	printf("c>>1 = %d\n", d);
//
//	return 0;
//}
//警告：对于移位操作符，不要移动负数位，这个是标准未定义的
//例如： int num = 10;
//       num >> -1;








//		位操作符
//      移位操作符和位操作符只能应用于整数，不能用浮点数

//      移位操作符,位操作符,按位取反,运算,隐式类型转换，都是用补码进行计算，只不过正数的补码原码反码相同

//#include <stdio.h>
//
//int main()
//{
//	int a = 3;
//	int b = 5;
//	int c = a & b; //按位或 对应二进制相同为一
//	//00000011
//	//00000101
//	//00000001
//
//	int d = a | b; //按位与 对应二进制有一为一
//	//00000011
//	//00000101
//	//00000111
//
//	int e = a ^ b; //按位异或 对应二进制相同为零，不相同为一
//	//00000011
//	//00000101
//	//00000110
//
//	//位操作都是二进制补码进行 与运算/或运算/异或运算
//
//	printf("a&b = %d\n\n", c);
//	printf("a|b = %d\n\n", d);
//	printf("a^b = %d\n\n", e);
//
//	return 0;
//}






//题目：交换两个变量,要求不创建临时变量


//#include <stdio.h>
//
//int main()
//{
//	int a = 3;
//	int b = 5;
//
//	a = a + b; //8
//	b = a - b; //3
//	a = a - b; //5
//
//	printf("a = %d\tb = %d", a, b);
//
//	return 0;
//}
//加减法
//有缺陷：若两个数字都非常大，接近int类型的极限，加起来就会溢出，得到的值就不是真实相加的值,有精度缺失



//#include <stdio.h>
//int main()
//{
//	int a = 3;
//	int b = 5;
//
//	a = a ^ b;
//	b = a ^ b;
//	a = a ^ b;
//
//	//int o = 3;
//	//int c = a ^ o;
//
//	//printf("c = %d\n", c);
//
//	printf("a = %d\tb = %d\n", a, b);
//
//	return 0;
//}

// a与b异或得到c,c再异或b会得到a,c异或b(原先的a)会得到a(原先的b)
// 有点像a和b相加得到c, c-a=b, c-b = a

//按位异或法
//任何两个数如果不用第三个变量来交换变量，可以通过异或三次来交换；
//异或算法不会造成数溢出,因为两个数只会计算是否相同相异，不会进位

//缺点：执行效率低,不如三个变量交换快，可读性也低








//题目：编写代码实现：求一个整数存储在内存中的二进制中1的个数

//方法1.
//#include <stdio.h>
//
//int main()
//{
//	unsigned int num = -1;
//	int count = 0;
//	
//	while (num)
//	{
//		if (num % 2 == 1)
//		{
//			count++;	
//		}
//		num = num / 2;	//注意这一点！！ 不是num/2,是num=num/2,num/2的值要存储在一个变量里面
//	}
//	printf("二进制中1的个数 = %d\n", count);
//
//	return 0;
//}
// 
//缺陷，对负数不管用,要想不改变大框架写出正确代码，把int改成unsigned就行




//方法2

//#include <stdio.h>
//
//int main()
//{
//	int num = 0;
//
//	printf("请输入数字");
//	scanf("%d", &num);
//
//	int i = 0;
//	int count = 0;
//
//	//每一个整型都是32位，如果一个整型数与1做&与运算，整型数最右边的值和1与运算结果为1，说明这个整型数最右边的二进制数是1
//	//00000000 00000000 00000000 00000101
//	//00000000 00000000 00000000 00000001
//	//让每一位都与1做与运算,等于1的位就计数count++,就可以得到一个整型数二进制中1的个数
//
//	for (i = 0; i < 32; i++)
//	{
//		if (num & (1 << i))
//		{
//			count++;
//		}
//	}
//
//	printf("二进制中1的个数是 = %d\n", count);
//
//	return 0;
//}








//赋值操作符

//#include <stdio.h>
//
//int main()
//{
//
//	//创建变量叫初始化
//	int i = 10;
//
//	//给创建的变量一个值叫赋值
//	i = 20;
//
//	//连续赋值
//	int a = 10;
//	int x = 5;
//	int y = 20;
//
//	a = x = y + 1;
//	printf("%d\n", a);
//
//	return 0;
//}



//复合赋值符
//+=
//-=
//*=
///=
//%=

//>>=
//<<=

//&=
//|=
//^=





//单目操作符



// ！ 逻辑反操作

//#include <stdio.h>
//
//int main()
//{
//	int a = 0;
//	printf("%d\n", !a);
//	//单目操作符: !,作用是 逻辑反操作，如上代码，10为非0为真，反操作就是假(0)
//
//
//	if (a) //假如a为真
//	{
//		printf("hehe\n");
//	}
//
//	if (!a) //假如a为假
//	{
//		printf("haha\n");
//	}	
//	
//	return 0;
//}


//负值  -

//#include <stdio.h>
//
//int main()
//{
//	int a = 10;
//
//	a = -a;
//
//	return 0;
//}



//&  取地址操作符

//#include <stdio.h>
//
//int main()
//{
//	int a = 10;
//
//	int* pa = &a;   //取的地址只能由指针变量存放
//
//	int ret = *pa;  //*pa的*是解引用操作符，作用是通过pa存放的地址，找到所指向的对象,*pa就是a
//
//	printf("ret=%d\n", ret);
//
//	return 0;
//}




//sizeof  计算变量所占空间的大小

//#include <stdio.h>
//
//int main()
//{
//	int a = 10;
//	char c = 'r';
//	char* p = &c;
//	int arr[10] = { 0 };
//
//	//sizeof 计算 变量 所占空间的大小,单位是字节
//	printf("%d\n", sizeof(a));
//	printf("%d\n\n", sizeof(int));
//
//	printf("%d\n", sizeof(c));
//	printf("%d\n\n", sizeof(char));
//
//	printf("%d\n", sizeof(p));
//	printf("%d\n\n", sizeof(char*));
//
//	printf("%d\n", sizeof(arr));
//	printf("%d\n", sizeof(int [10]));
//	printf("%d\n\n", sizeof(int [5]));
//
//	//数组的类型就是 数组前面的类型+[]
//
//	short s = 0;
//	int b = 10;
//
//	printf("%d\n", sizeof(short));
//	printf("%d\n", sizeof(s = a + 5));	//把长整型放进短整型，结果由短整型决定
//	printf("%d\n", s);					//s还是0,因为sizeof里的运算不是真实发生并且真实赋值的
//	
//
//	return 0;
//}





//	~按位取反

//#include <stdio.h>
//
//int main()
//{
//	int a = 0;
//	//补码:00000000 00000000 00000000 00000000
//	//取反:11111111 11111111 11111111 11111111	//补码取反包括符号位也要取反
//	//因为取反后的依然是补码，所以打印出来还是要转换成原码
//	//反码:11111111 11111111 11111111 11111110   //因为取反后符号位是负数，取反后再转反码符号位不变
//	//原码:10000000 00000000 00000000 00000001
//
//	printf("%d\n", ~a);
//
//	return 0;
//}
//按位取反也是补码进行取反






//题目，把一个数二进制位任意一位改成1

//#include <stdio.h>
//
//int main()
//{
//	int a = 11;
//
//	a = a | (1 << 2);	//想要修改二进制的哪位，就修改2
//	//00000000 00000000 00000000 00001011	a
//	//00000000 00000000 00000000 00000100	1<<2
//
//
//	//以上代码是15，如果想还原成11该怎么做呢？
//	//00000000 00000000 00000000 00001111	// 15
//	//11111111 11111111 11111111 11111011	//上面代码与这行代码进行与运算,就能还原，但是怎么得到这行代码呢？
//	//00000000 00000000 00000000 00001011	// 11
//
//	//00000000 00000000 00000000 00000100	//只需要把这行代码按位取反，再和15的二进制或运算，就能还原成11了
//
//	a = a & (~(1 << 2));
//
//	//a = a ^ (1 << 2);		这种也可以还原
//
//
//	printf("%d\n", a);
//
//	return 0;
//}





//++ --   前置++ --，后置++ --

//#include <stdio.h>
//
//int main()
//{
//	int a = 10;
//	printf("++a = %d\n", ++a);
//	printf("a++ = %d\n", a++);
//	//谁离等号进，谁先进行
//
//	int b = 10;
//	int c = ++b;
//	printf("%d\n", c);
//	
//	return 0;
//}





// (类型)	强制类型转换

//#include <stdio.h>
//
//int main()
//{
//	int a = (int)3.14;
//
//	printf("%d\n", a);
//
//	return 0;
//}








//题目：说出以下四个printf输出的都是什么

//#include <stdio.h>
//
//void test1(int arr[])
//{
//	printf("%d\n", sizeof(arr));	//(3)
//}
//
//void test2(char ch[])
//{
//	printf("%d\n", sizeof(ch));		//(4)
//}
//
//int main()
//{
//	int arr[10] = { 0 };
//	char ch[10] = { 0 };
//
//	printf("%d\n", sizeof(arr));	//(1)
//	printf("%d\n", sizeof(ch));		//(2)
//
//	test1(arr);
//	test2(ch);
//
//	return 0;
//}


//为什么（3）和（4）输出都是8 ？因为函数传过去的是数组首元素的地址，既然是地址，接收的类型就是指针变量
//指针变量在32位系统上面是4字节，在64位系统上面是8字节




//	关系操作符
//  >
//  >=
//  <
//  <=
//  !=
//  ==






//	逻辑操作符

// &&逻辑与		需要和按位与区分，逻辑与关注的是这个数本身是真还是假
// ||逻辑或

// 1 && 3 = 1
// 1 || 3 = 1




//题目1：程序输出的结果是什么？

//#include <stdio.h>
//
//int main()
//{
//	int i = 0, a = 0, b = 2, c = 3, d = 4;
//
//	i = a++ && ++b && d++;
//
//	printf("i = %d\n",i);
//	printf(" a=%d\n b=%d\n c=%d\n d=%d\n",a,b,c,d);
//	//逻辑与只要左边算得为0，右边都不再进行运算，总体结果为假（0）
//
//	return 0;
//}




//题目2

//#include <stdio.h>
//
//int main()
//{
//	int i = 0, a = 1, b = 2, c = 3, d = 4;
//
//	i = a++ && ++b && d++;
//
//	printf(" a=%d\n b=%d\n c=%d\n d=%d\n", a, b, c, d);
//
//	return 0;
//}


//题目3

//#include <stdio.h>
//
//int main()
//{
//	int i = 0, a = 1, b = 2, c = 3, d = 4;
//
//	i = a++ || ++b || d++;
//	// 逻辑或，只要前面为真，后面都不进行运算，不管后面真假，总体结果都为真
//
//	printf(" a=%d\n b=%d\n c=%d\n d=%d\n", a, b, c, d);
//
//	return 0;
//}




//题目4

//#include <stdio.h>
//
//int main()
//{
//	int i = 0, a = 0, b = 2, c = 3, d = 4;
//
//	i = a++ || ++b || d++;
//
//	printf("%d\n", i);  
//	printf(" a=%d\n b=%d\n c=%d\n d=%d\n", a, b, c, d);  
//}







//	条件操作符(三目操作符)

//exp1 ? exp2 : exp3

//如果表达式1为真，表达式2要算，表达式2的结果是整个表达式的结果
//如果表达式1为假，表达式3要算，表达式3的结果是整个表达式的结果


//题目，把以下代码改写成三目操作符（条件操作符）的形式

//#include <stdio.h>
//
//int main()
//{
//	if (a > 5)
//	{
//		b = 3;
//	}
//	else
//	{
//		b = -1;
//	}
//}



//#include <stdio.h>
//
//int main()
//{
//	int a = 0;
//	int b = 0;
//
//	b = (a > 5 ? 3 : -1);
//
//	printf("%d\n", b);
//
//	return 0;
//}




//用条件操作符（三目操作符）求a与b的较大值

//#include <stdio.h>
//
//int main()
//{
//	int a = 10;
//	int b = 20;
//
//	printf("%d\n", a > b ? a : b);
//
//	return 0;
//}





//	逗号操作符

//逗号表达式，就是用逗号隔开的多个表达式。逗号表达式，从左向右依次执行。
// 整个表达式的结果是最后一个表达式的结果

//exp1,exp2,exp3,...expN

//#include <stdio.h>
//
//int main()
//{
//	int a = 1;
//	int b = 2;
//	int c = (a > b, a = b + 10, a, b = a + 1);
//	//表达式里面的运算都是真实运算并且真实赋值的
//
//	printf("%d\n", a);
//	printf("%d\n", c);
//
//	return 0;
//}







//#include <stdio.h>
//
//int main()
//{
//	int a = 2;
//	int b = 2;
//	int c = 3;
//	int d = 4;
//
//	if (a = b + 1, c = a / 2, d > 0)
//	{
//		printf("哈哈哈\n");
//	}
//
//	printf("a=%d\n", a);
//	printf("b=%d\n", b);
//	printf("c=%d\n", c);
//
//	return 0;
//}



//用逗号表达式改写
//#include <stdio.h>
//
//int main()
//{
//	a = get_val();
//	count_val(a);
//
//	while (a > 0)
//	{
//		a = get_val();
//		count_val(a);
//	}
//}



//用逗号表达式改写上面代码
//#include <stdio.h>
//
//int main()
//{
//	while (a = get_val(), count_val(a), a > 0)
//	{
//
//	}
//}





//	下标引用，函数调用和结构成员


//下标引用操作符
//#include <stdio.h>
//
//int main()
//{
//	int arr[4] = { 0 };
//	//操作数:一个数组名+一个索引值
//	//例如 1+2，+号就有两个操作数，分别是1和2
//	//[]也有两个操作数，分别是数组名(arr) 和 []里的下标(4) 
//  //所以下标引用操作符也是双目操作符
//
//}



//函数调用

//#include <stdio.h>
//
////         这对圆括号不是函数调用操作符，是定义函数的语法规则
//int get_max(int a, int b)
//{
//	if (a > b)
//	{
//		return a;
//	}
//	else if (b > a)
//	{
//		return b;
//	}
//}
//
//int main()
//{
//	int a = 10;
//	int b = 20;
//	//调用函数的时候的()就是函数调用操作符
//	int max = get_max(a, b);
//	//这里的函数调用操作符有三个操作数(三目操作符)
//	//分别是函数名（get_max）,a,b
//
//	return 0;
//}







//访问结构成员

//#include <stdio.h>
//
////struct student也是一个类型， 类型的作用是创建变量
////创建一个结构体类型-struct student
//struct student
//{
//	//成员变量
//	char name[20];
//	int age;
//	char id[20];
//};
//
//
//int main()
//{
//	//使用struct student这个类型创建了一个对象- s1,并初始化
//	struct student s1 = { "黄冠",21,"202205010311" };
//
//	//访问方式1.
//	printf("s1.name = %s\n", s1.name);
//	printf("s1.age = %d\n", s1.age);
//	printf("s1.id = %s\n\n", s1.id);
//	// 结构体变量.成员名
//
//
//
//	//访问方式2.
//	struct student* ps = &s1;
//
//	printf("&ps = %p\n", &ps);
//	printf("s1.name = %s\n", (*ps).name);
//	//	*ps解引用操作，指向的就是s1,
//	printf("s1.age = %d\n", (*ps).age);
//	printf("s1.id = %d\n\n", (*ps).id);
//
//	//既然s1是变量，那就一定会占据一定的内存空间，而且一定有地址
//	//地址只能用指针变量存储，结构体的指针变量的类型就是struct+结构体名
//	//但第二种方式略显嗦，C语言还提供了第三种方式
//
//
//
//	//访问方式3.
//	printf("s1.name = %s\n", ps->name);
//	printf("s1.age = %d\n", ps->age);
//	printf("s1.id = %d\n", ps->id);
//	//->:结构体指针指向操作符
//	//结构体指针->成员名
//	//->就是指向对象的内部
//
//	return 0;
//}






//表达式求值
//表达式求值的顺序一部分是由操作符的优先级和结合性决定的
//同样，有些表达式的操作数在求值的过程中可能需要转换为其他类型

//隐式类型转换
//c的整型算数运算总是至少以缺省整型类型的精度来决定的。
//为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换称为整型提升

//整型提升的意义：
//表达式的整型运算要在CPU的相应运算器内执行，CPU内整型运算器(ALU)的操作数的字节长度
//一般就是int的字节长度，同时也是CPU的通用寄存器的长度。只要进行运算的类型小于int类型,都会进行整型提升

//因此，即便两个char类型的相加，在CPU执行时实际上也要先转换为CPU内部整型操作数的标准长度。

//通用CPU是难以直接实现两个8比特字节直接相加运算(虽然机器指令中可能有这种字节相加指令)。
//所以，表达式中各种长度可能小于int长度的整型值，都必须先转换为int或unsigned int,然后才能送入CPU去执行计算




//隐式类型转换
//#include <stdio.h>
//
//int main()
//{
//	char a = 3;
//	//00000000 00000000 00000000 00000011
//	//把一个整型数字'3'放进字符类型char里面，会造成二进制截断，取最低位，结果为:
//	//00000011
//	
//	char b = 127;
//	//00000000 00000000 00000000 01111111
//	//01111111
//
//	//如何进行整型提升
//	//整型提升是按照变量的数据类型的符号位来提升的，符号位为0，左边全部补0，左边符号位为1，全部补1,补满32位
//	//提升完之后变成整型，整型进行加减乘除
//	char c = a + b;
//	//b和c要加的话，首先a和b的值被提升为普通整型，然后再执行加法运算。
//	//00000000 00000000 00000000 00000011
//	//00000000 00000000 00000000 01111111
//	//00000000 00000000 00000000 10000010
//	//加法运算完成之后，因为c是char类型，结果将被截断，然后再存储于a中
//	
//	//c = 10000010
//	
//	printf("%d\n", c);
//	//但由于要打印的是%d,c是char类型的,所以还要进行一次整型提升
//	//10000010 整型提升
//	//11111111 11111111 11111111 10000010（补码）
//	//11111111 11111111 11111111 10000001（反码）
//	//10000000 00000000 00000000 01111110（补码）
//
//	return 0;
//}





//#include <stdio.h>
//
//int main()
//{
//	char a = -1;
//	//10000000 00000000 00000000 00000001 (变量a的二进制（原码）)
//	//11111111 11111111 11111111 11111110
//	//11111111 11111111 11111111 11111111(补码)
//	//11111111(补码最低位截断) 存到 char a里面
//	//%d 整型提升 11111111 11111111 11111111 11111111(补码)
//	//			 11111111 11111111 11111111 11111110(反码)
//	//           10000000 00000000 00000000 00000001(原码)
//
//	printf("%d\n", a);
//
//	return 0;
//}





// 0x后面跟的是16进制的整型

// 0xb6放进char: 10110110 
//				 11111111 11111111 11111111 10110110
//				 11111111 11111111 11111111 10110101
//				 10000000 00000000 00000000 01001010  2+8+64 = -74

// 0xb6放进int:	10110110 2+4+16+32+128 = 182

//#include <stdio.h>
//
//int main()
//{
//	int a = 0xb6;
//	char b = 0xb6;
//	
//	printf("int a = %d\n", a);
//	printf("char b = %d\n", b);
//
//	return 0;
//}



//如何证明隐式提升真实存在
//题目：结果会打印什么

//#include <stdio.h>
//
//int main()
//{
//	char a = 0xb6;
//	short b = 0xb600;
//	int c = 0xb6000000;
//
//	if (a == 0xb6)
//	{
//		printf("a");
//	}
//
//	if (b == 0xb600)
//	{
//		printf("b");
//	}
//
//	if (c == 0xb6000000)
//	{
//		printf("c");
//	}
//
//	return 0;
//}

//为什么c可以打印，因为c是整型，不用整型提升
//为什么a,b不会打印，因为a,b都不是整型，和整型a进行比较时(比较也算是一种运算)会整型提升，提升后与0xb6就不同了



//题目

//#include <stdio.h>
//
//int main()
//{
//	char c = 1;
//
//	//%u 无符号整型输出格式 unsigned int
//	printf("%u\n", sizeof(c));
//
//	printf("%u\n", sizeof(+c));
//	// +c(正c),进行了整型提升
//
//	printf("%u\n", sizeof(!c));
//	//!c就是0，0放进去就会截断，还是char
//
//	return 0;
//}





//算术转换（算术转换也是一种隐式类型转换）

//如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数转换为另一个操作数的类型
//否则操作就无法进行。下面的层次体系称为 寻常算数转换

//int 与比int高的类型进行运算的时候，称为算术转换

// long doeble
// double
// float
// unsigned long int
// long int
// unsigned int
// int


//如果某个操作数的类型在上面这个列表排名较低，
//那么首先要转换为另一个操作数的类型后执行运算

//警告：但是算术转换要合理，要不然会有一些潜在问题

//float f = 3.14
//int num = f;  //隐式转换，会有精度丢失





//操作符的属性
//复杂表达式的求值有三个影响的因素
//1.操作符的优先级
//2.操作符的结合性
//3.是否控制求值顺序

//两个相邻的操作符先执行哪个？取决于他们的优先级。
//如果两者的优先级相同，取决于他们的结合性

//优先级
//结合性

//优先级
//#include <stdio.h>
//
//int main()
//{
//	int a = 10;
//	int b = 20;
//	int c = a + b * 3;
//	//操作符*先算，这就是操作符的优先性
//
//	return 0；
//}


//结合性
//#include <stdio.h>
//
//int main()
//{
//	int a = 10;
//	int b = 20;
//	int c = a + b + 30;
//	//操作符相同，但是+号的操作符是从左到右开始算的，a+b先算，算完再+30，这就是操作符的结合性
//	
//	//结合性分为L-R(从左到右结合),R-L(从右到左结合),和N/A(无结合性)比如函数调用操作符:()
//	//逻辑与&&	逻辑或||		条件操作符?:		逗号操作符, 都具有控制求值顺序的功能
//	//控制求值顺序的意思是一部分表达式运算，一部分表达式不运算
//	
//
//	return 0；
//}





//非法表达式1.
//#include <stdio.h>
//
//int main()
//{
//	int ret = a * b + c * d + e * f;
//	//如果a,b,c,d,e,f分别都是表达式，那这样写可能就会得到错误的结果
//	return 0;
//}




//非法表达式2..
//#include <stdio.h>
//
//int main()
//{
//	int c = 1;
//	c = c + --c;
//	//这段表达式是有歧义的,我们只知道--的优先级高于+,不知道它准备之前是给--c赋值先，还是c赋值先，C赋值先C等于1，1+0=1
//	//--c赋值先，c就等于0，在赋值给前面那个C也是0，0+0=0,一个表达式两种结果。
//	
//	printf("%d\n", c);
//
//	return 0;
//}





//非法表达式3.
//#include <stdio.h>
//
//int main()
//{
//	int i = 0;
//
//	i = i-- - i++ * (i = -3) * i++ + ++i;
//	printf("i=%d\n", i);
//
//	return 0;
//}

//非法表达式，不同编译器算出的结果都不一样，所以避免写这样的代码
//要写出通过操作符的属性确定唯一的计算路径的表达式，否则代码就是错误的




//非法表达式4.
//#include <stdio.h>
//
//int fun()
//{
//	static int count = 1;
//	return ++count;
//}
//
//int main()
//{
//	int answer = 0;
//
//	answer = fun() - fun() * fun();
//	//我们没有办法知道是什么顺序，是第一个fun()函数先进行，还是后面的fun()先进行
//	printf("%d\n", answer);
//
//	return 0;
//}




//非法表达式5.
//#include <stdio.h>
//
//int main()
//{
//	int i = 0;
//	int ret = (++i) + (++i) + (++i);
//	printf("%d\n", ret);
//	printf("%d\n", i);
//
//	return 0;
//}


